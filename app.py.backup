import os
import logging
import calendar
from flask import Flask, render_template, request, redirect, url_for, flash, send_from_directory, session, g, jsonify
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.orm import DeclarativeBase
from werkzeug.utils import secure_filename
from functools import wraps
from flask_session import Session
from flask_wtf.csrf import CSRFProtect
import uuid
from datetime import datetime, timedelta
import shutil
import json

# Set up logging with more detailed format
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'
)

# Define base class for SQLAlchemy models
class Base(DeclarativeBase):
    pass

# Initialize SQLAlchemy with the base class
db = SQLAlchemy(model_class=Base)

# Create Flask app
app = Flask(__name__)
app.secret_key = os.environ.get("SESSION_SECRET", "default_secret_key_for_development")

# Ajouter des filtres pour les templates
@app.template_filter('pprint')
def pprint_filter(value):
    import pprint
    return pprint.pformat(value)

@app.template_filter('nl2br')
def nl2br_filter(value):
    """Convert newlines to <br> tags."""
    # La classe Markup a été déplacée vers markupsafe dans les nouvelles versions
    from markupsafe import Markup
    value = str(value)  # Convertir en chaîne de caractères
    paragraphs = value.split('\n\n')
    result = ''
    for p in paragraphs:
        if p.strip():
            p = p.replace('\n', '<br>')
            result += f'<p>{p}</p>'
    return Markup(result)

# Configuration des sessions simplifiée - Utilisation de cookies pour les sessions
app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(days=31)
app.config['SESSION_TYPE'] = 'filesystem'
app.config['SESSION_FILE_DIR'] = 'flask_session'
app.config['SESSION_COOKIE_SECURE'] = False  # Pour permettre HTTP en développement
app.config['SESSION_COOKIE_HTTPONLY'] = True
app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'  # Plus compatible avec les navigateurs modernes
app.config['SESSION_USE_SIGNER'] = False  # Désactivation pour tester
app.config['SESSION_PERMANENT'] = True  # Les sessions sont permanentes par défaut

# Protection CSRF
app.config['WTF_CSRF_ENABLED'] = True
app.config['WTF_CSRF_SECRET_KEY'] = app.secret_key

# Configure SQLite database
app.config["SQLALCHEMY_DATABASE_URI"] = os.environ.get("DATABASE_URL", "sqlite:///property_management.db")
app.config["SQLALCHEMY_ENGINE_OPTIONS"] = {
    "pool_recycle": 300,
    "pool_pre_ping": True,
}
app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False

# Configure file uploads
app.config['UPLOAD_FOLDER'] = 'static/uploads'
app.config['ALLOWED_EXTENSIONS'] = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif', 'doc', 'docx'}
app.config['MAX_CONTENT_LENGTH'] = 50 * 1024 * 1024  # 50MB max upload size (pour morceaux individuels, le téléversement par chunks gère des fichiers plus grands)

# CSRF protection already configured above

# Initialize the app with SQLAlchemy
db.init_app(app)

# Initialize Flask-Session
Session(app)

# Initialize CSRF Protection but disable it for now
app.config['WTF_CSRF_ENABLED'] = False  # Temporarily disable CSRF for development
csrf = CSRFProtect(app)

# Ensure the upload directory exists
os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)

# Fonction pour vérifier automatiquement les paiements en retard
@app.before_request
def check_late_payments():
    """Vérifier automatiquement les paiements en retard à chaque requête"""
    # Ne pas exécuter pour les requêtes statiques ou les endpoints non critiques
    if request.endpoint and (
        request.endpoint.startswith('static') or 
        request.endpoint in ['login', 'logout', 'uploaded_file']
    ):
        return
    
    # Importer Payment ici pour éviter les erreurs d'importation circulaire
    from models import Payment
    
    # Vérifier et mettre à jour le statut des paiements en retard
    today = datetime.now().date()
    payments = Payment.query.filter_by(status='En attente').all()
    updated = False
    
    for payment in payments:
        if payment.is_rent_payment() and payment.check_late_status():
            payment.status = 'En retard'
            updated = True
    
    if updated:
        try:
            db.session.commit()
            logging.info(f"Mise à jour automatique des paiements en retard - {datetime.now()}")
        except Exception as e:
            db.session.rollback()
            logging.error(f"Erreur lors de la mise à jour des paiements en retard: {str(e)}")

# Import models after db is defined
from models import Property, Document, Building, User, Payment

# Décorateur personnalisé pour remplacer @login_required avec plus de logging
def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        logging.info(f"Vérification login_required - Session: {session}")
        
        if 'user_id' not in session:
            logging.warning(f"Accès refusé: user_id non trouvé dans la session")
            flash('Veuillez vous connecter pour accéder à cette page.', 'info')
            return redirect(url_for('login', next=request.url))
        
        # Vérifier que l'utilisateur existe toujours en base
        user = User.query.get(session['user_id'])
        if not user:
            logging.warning(f"Accès refusé: user_id {session['user_id']} non trouvé en base de données")
            session.clear()
            flash('Session invalide. Veuillez vous reconnecter.', 'warning')
            return redirect(url_for('login', next=request.url))
            
        logging.info(f"Accès autorisé pour l'utilisateur {user.username} (ID: {user.id})")
        return f(*args, **kwargs)
    return decorated_function

# Fonction pour récupérer l'utilisateur actuel
def get_current_user():
    if 'user_id' in session:
        user = User.query.get(session['user_id'])
        if user:
            return user
        else:
            # Si l'utilisateur n'existe pas en base mais est en session, nettoyer la session
            session.clear()
    return None

# Injecter l'utilisateur dans tous les templates + informations de session
@app.context_processor
def inject_user():
    # Récupérer l'utilisateur actuel
    current_user = get_current_user()
    
    # Informations additionnelles pour le debug
    session_info = {
        'has_user_id': 'user_id' in session,
        'is_authenticated': current_user is not None,
    }
    
    logging.info(f"Context processor - Session info: {session_info}")
    
    # Retourner les variables pour les templates
    return {
        'current_user': current_user,
        'session_info': session_info
    }

# Middleware pour vérifier l'utilisateur à chaque requête
@app.before_request
def load_logged_in_user():
    user_id = session.get('user_id')
    if user_id:
        g.user = User.query.get(user_id)
    else:
        g.user = None


def allowed_file(filename):
    """Check if the file extension is allowed"""
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']


def generate_unique_filename(filename):
    """Generate a unique filename to prevent overwrites"""
    # Get file extension
    ext = filename.rsplit('.', 1)[1].lower() if '.' in filename else ''
    # Create a unique name with timestamp and UUID
    unique_name = f"{datetime.now().strftime('%Y%m%d%H%M%S')}_{uuid.uuid4().hex}"
    if ext:
        unique_name = f"{unique_name}.{ext}"
    return unique_name


# Routes
@app.route('/')
@login_required
def index():
    """Display all properties with optional filter by owner company"""
    # Récupérer le paramètre de filtre de la société propriétaire
    owner_company = request.args.get('owner_company', '')
    
    # Filtrer les propriétés en fonction du paramètre
    if owner_company:
        properties = Property.query.filter(Property.owner_company.ilike(f'%{owner_company}%')).all()
    else:
        properties = Property.query.all()
    
    return render_template('index.html', properties=properties)


@app.route('/dashboard')
@login_required
def dashboard():
    """Afficher le tableau de bord avec les statistiques"""
    # Récupérer les statistiques de base
    properties_count = Property.query.count()
    buildings_count = Building.query.count()
    documents_count = Document.query.count()
    
    # Récupérer tous les paiements
    payments = Payment.query.all()
    
    # Vérifier et mettre à jour le statut des paiements en retard
    today = datetime.now().date()
    updated = False
    
    for payment in payments:
        if payment.is_rent_payment() and payment.check_late_status():
            payment.status = 'En retard'
            updated = True
    
    if updated:
        db.session.commit()
    
    # Récupérer à nouveau les paiements après mise à jour
    if updated:
        payments = Payment.query.all()
    
    # Calculer les totaux par statut
    paid_total = sum(payment.amount for payment in payments if payment.status == 'Payé')
    pending_total = sum(payment.amount for payment in payments if payment.status == 'En attente')
    late_total = sum(payment.amount for payment in payments if payment.status == 'En retard')
    
    # Calculer le montant total des paiements
    total_payments = paid_total + pending_total + late_total
    
    # Récupérer les 5 derniers paiements
    recent_payments = Payment.query.order_by(Payment.payment_date.desc()).limit(5).all()
    
    # Récupérer les paiements à venir (loyers du mois en cours et à venir)
    first_day_current_month = datetime(today.year, today.month, 1).date()
    upcoming_payments = Payment.query.filter(
        Payment.payment_type == 'Loyer',
        Payment.status == 'En attente',
        Payment.payment_date >= first_day_current_month
    ).order_by(Payment.payment_date.asc()).all()
    
    # Calculer les jours restants jusqu'à la date limite pour chaque paiement
    for payment in upcoming_payments:
        due_date = payment.get_due_date()
        payment.days_remaining = (due_date - today).days
    
    # Filtrer pour ne garder que les paiements avec des jours restants >= 0
    upcoming_payments = [p for p in upcoming_payments if getattr(p, 'days_remaining', -1) >= 0]
    
    # Récupérer les 5 dernières propriétés ajoutées
    recent_properties = Property.query.order_by(Property.created_at.desc()).limit(5).all()
    
    return render_template(
        'dashboard.html',
        properties_count=properties_count,
        buildings_count=buildings_count,
        documents_count=documents_count,
        paid_total=paid_total,
        pending_total=pending_total,
        late_total=late_total,
        total_payments=total_payments,
        recent_payments=recent_payments,
        recent_properties=recent_properties,
        upcoming_payments=upcoming_payments,
        today=today
    )


@app.route('/property/add', methods=['GET', 'POST'])
@login_required
def add_property():
    """Add a new property"""
    if request.method == 'POST':
        # Vérifier si c'est une soumission en double (POST-Redirect-GET)
        # Si c'est une soumission directe, continuer
        is_form_submit = request.form.get('_form_submit_direct') == '1'
        
        if is_form_submit:
            # Mettre un marqueur dans la session pour éviter les soumissions multiples
            form_token = str(uuid.uuid4())
            session['last_form_token'] = form_token
            
            address = request.form.get('address')
            rent = request.form.get('rent')
            charges = request.form.get('charges')
            tenant = request.form.get('tenant')
            tenant_email = request.form.get('tenant_email')
            tenant_phone = request.form.get('tenant_phone')
            
            # Informations du propriétaire
            owner_company = request.form.get('owner_company')
            owner_address = request.form.get('owner_address')
            
            # Caractéristiques du bien
            deposit = request.form.get("deposit")
            surface = request.form.get('surface')
            floor = request.form.get('floor')
            location = request.form.get('location')
            entry_date = request.form.get('entry_date')
            
            if not address or not rent or not charges:
                flash('Adresse, loyer et charges sont des champs obligatoires', 'danger')
                return redirect(url_for('add_property'))
            
            try:
                # Vérifier si une propriété avec cette adresse existe déjà
                existing_property = Property.query.filter_by(address=address).first()
                if existing_property:
                    similar_properties = Property.query.filter(Property.address.ilike(f"%{address}%")).all()
                    if len(similar_properties) > 0:
                        flash(f'Une propriété avec une adresse similaire existe déjà. Veuillez vérifier les propriétés existantes.', 'warning')
                
                # Créer un nouveau bien immobilier
                new_property = Property(
                    address=address,
                    rent=float(rent),
                    charges=float(charges),
                    tenant=tenant,
                    tenant_email=tenant_email,
                    tenant_phone=tenant_phone,
                    owner_company=owner_company,
                    owner_address=owner_address,
                    deposit=float(deposit) if deposit and deposit.strip() else None,
                    surface=float(surface) if surface and surface.strip() else None,
                    floor=floor,
                    location=location,
                    entry_date=datetime.strptime(entry_date, '%Y-%m-%d').date() if entry_date else None
                )
                db.session.add(new_property)
                db.session.commit()
                
                flash('Bien immobilier ajouté avec succès !', 'success')
                # Rediriger pour éviter les soumissions multiples (PRG pattern)
                return redirect(url_for('property_detail', property_id=new_property.id))
            except Exception as e:
                db.session.rollback()
                flash(f'Erreur lors de l\'ajout du bien immobilier: {str(e)}', 'danger')
                logging.error(f"Erreur lors de l'ajout du bien immobilier: {str(e)}")
    
    return render_template('add.html')


@app.route('/property/<int:property_id>')
@login_required
def property_detail(property_id):
    """Display property details and associated documents"""
    property = Property.query.get_or_404(property_id)
    documents = Document.query.filter_by(property_id=property_id).all()
    buildings = Building.query.all()
    return render_template('detail.html', property=property, documents=documents, buildings=buildings)


@app.route('/property/<int:property_id>/edit', methods=['GET', 'POST'])
@login_required
def edit_property(property_id):
    """Edit an existing property"""
    property = Property.query.get_or_404(property_id)
    
    if request.method == 'POST':
        address = request.form.get('address')
        rent = request.form.get('rent')
        charges = request.form.get('charges')
        tenant = request.form.get('tenant')
        tenant_email = request.form.get('tenant_email')
        tenant_phone = request.form.get('tenant_phone')
        
        # Informations du propriétaire
        owner_company = request.form.get('owner_company')
        owner_address = request.form.get('owner_address')
        
        # Caractéristiques du bien
        deposit = request.form.get("deposit")
        surface = request.form.get('surface')
        floor = request.form.get('floor')
        location = request.form.get('location')
        entry_date = request.form.get('entry_date')
        
        if not address or not rent or not charges:
            flash('Address, rent, and charges are required fields', 'danger')
            return redirect(url_for('edit_property', property_id=property_id))
        
        try:
            # Update property details
            property.address = address
            property.rent = float(rent)
            property.charges = float(charges)
            property.tenant = tenant
            property.tenant_email = tenant_email
            property.tenant_phone = tenant_phone
            property.owner_company = owner_company
            property.owner_address = owner_address
            property.surface = float(surface) if surface else None
            property.deposit = float(deposit) if deposit else None
            property.floor = floor
            property.location = location
            property.entry_date = datetime.strptime(entry_date, '%Y-%m-%d').date() if entry_date else None
            
            db.session.commit()
            
            flash('Property updated successfully!', 'success')
            return redirect(url_for('property_detail', property_id=property.id))
        except Exception as e:
            db.session.rollback()
            flash(f'Error updating property: {str(e)}', 'danger')
            logging.error(f"Error updating property: {str(e)}")
    
    return render_template('edit.html', property=property)


@app.route('/property/<int:property_id>/upload', methods=['POST'])
@login_required
def upload_document(property_id):
    """Upload a document for a property"""
    property = Property.query.get_or_404(property_id)
    
    # Check if the post request has the file part
    if 'document' not in request.files:
        flash('No file part', 'danger')
        return redirect(url_for('property_detail', property_id=property_id))
    
    file = request.files['document']
    
    # If user does not select file, browser submits an empty part without filename
    if file.filename == '':
        flash('No selected file', 'danger')
        return redirect(url_for('property_detail', property_id=property_id))
    
    if file and allowed_file(file.filename):
        # Secure the filename and make it unique
        filename = secure_filename(file.filename)
        unique_filename = generate_unique_filename(filename)
        
        # Save the file
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], unique_filename)
        file.save(file_path)
        
        # Create document record in database
        document = Document(
            property_id=property_id,
            filename=filename,  # Original filename for display
            filepath=unique_filename  # Actual filename on server
        )
        db.session.add(document)
        db.session.commit()
        
        flash('Document uploaded successfully!', 'success')
    else:
        flash('File type not allowed', 'danger')
    
    return redirect(url_for('property_detail', property_id=property_id))


@app.route('/uploads/<filename>')
@login_required
def uploaded_file(filename):
    """Serve uploaded files"""
    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)


@app.route('/document/<int:document_id>/delete', methods=['POST'])
@login_required
def delete_document(document_id):
    """Delete a document"""
    document = Document.query.get_or_404(document_id)
    property_id = document.property_id
    
    try:
        # Delete file from storage
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], document.filepath)
        if os.path.exists(file_path):
            os.remove(file_path)
        
        # Delete record from database
        db.session.delete(document)
        db.session.commit()
        
        flash('Document deleted successfully!', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting document: {str(e)}', 'danger')
        logging.error(f"Error deleting document: {str(e)}")
    
    return redirect(url_for('property_detail', property_id=property_id))


@app.route('/property/<int:property_id>/delete', methods=['POST'])
@login_required
def delete_property(property_id):
    """Delete a property and its associated documents"""
    property = Property.query.get_or_404(property_id)
    
    try:
        # Get all documents for this property
        documents = Document.query.filter_by(property_id=property_id).all()
        
        # Delete each document file
        for document in documents:
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], document.filepath)
            if os.path.exists(file_path):
                os.remove(file_path)
        
        # Delete the property (cascade will delete documents from DB)
        db.session.delete(property)
        db.session.commit()
        
        flash('Property and all associated documents deleted successfully!', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting property: {str(e)}', 'danger')
        logging.error(f"Error deleting property: {str(e)}")
    
    return redirect(url_for('index'))


# Routes for buildings
@app.route('/buildings')
@login_required
def buildings_list():
    """Display all buildings"""
    buildings = Building.query.all()
    return render_template('buildings/list.html', buildings=buildings)


@app.route('/building/add', methods=['GET', 'POST'])
@login_required
def add_building():
    """Add a new building"""
    if request.method == 'POST':
        name = request.form.get('name')
        address = request.form.get('address')
        description = request.form.get('description')
        
        if not name or not address:
            flash('Name and address are required fields', 'danger')
            return redirect(url_for('add_building'))
        
        try:
            # Create a new building
            new_building = Building(
                name=name,
                address=address,
                description=description
            )
            db.session.add(new_building)
            db.session.commit()
            
            flash('Building added successfully!', 'success')
            return redirect(url_for('building_detail', building_id=new_building.id))
        except Exception as e:
            db.session.rollback()
            flash(f'Error adding building: {str(e)}', 'danger')
            logging.error(f"Error adding building: {str(e)}")
    
    return render_template('buildings/add.html')


@app.route('/building/<int:building_id>')
@login_required
def building_detail(building_id):
    """Display building details and associated properties"""
    building = Building.query.get_or_404(building_id)
    properties = Property.query.filter_by(building_id=building_id).all()
    return render_template('buildings/detail.html', building=building, properties=properties)


@app.route('/building/<int:building_id>/edit', methods=['GET', 'POST'])
@login_required
def edit_building(building_id):
    """Edit an existing building"""
    building = Building.query.get_or_404(building_id)
    
    if request.method == 'POST':
        name = request.form.get('name')
        address = request.form.get('address')
        description = request.form.get('description')
        
        if not name or not address:
            flash('Name and address are required fields', 'danger')
            return redirect(url_for('edit_building', building_id=building_id))
        
        try:
            # Update building details
            building.name = name
            building.address = address
            building.description = description
            
            db.session.commit()
            
            flash('Building updated successfully!', 'success')
            return redirect(url_for('building_detail', building_id=building.id))
        except Exception as e:
            db.session.rollback()
            flash(f'Error updating building: {str(e)}', 'danger')
            logging.error(f"Error updating building: {str(e)}")
    
    return render_template('buildings/edit.html', building=building)


@app.route('/building/<int:building_id>/delete', methods=['POST'])
@login_required
def delete_building(building_id):
    """Delete a building"""
    building = Building.query.get_or_404(building_id)
    
    try:
        # Delete the building
        db.session.delete(building)
        db.session.commit()
        
        flash('Building deleted successfully!', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting building: {str(e)}', 'danger')
        logging.error(f"Error deleting building: {str(e)}")
    
    return redirect(url_for('buildings_list'))


@app.route('/property/<int:property_id>/assign', methods=['POST'])
@login_required
def assign_property_to_building(property_id):
    """Assign a property to a building"""
    property = Property.query.get_or_404(property_id)
    building_id = request.form.get('building_id')
    
    try:
        if building_id and building_id != "0":
            # Check if building exists
            building = Building.query.get_or_404(int(building_id))
            property.building_id = building.id
            message = f'Property assigned to building "{building.name}" successfully!'
        else:
            # Remove from building
            property.building_id = None
            message = 'Property removed from building successfully!'
        
        db.session.commit()
        flash(message, 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error assigning property to building: {str(e)}', 'danger')
        logging.error(f"Error assigning property to building: {str(e)}")
    
    return redirect(url_for('property_detail', property_id=property_id))


# Routes pour le chat avec l'assistant IA
@app.route('/chat', methods=['GET', 'POST'])
@login_required
def chat_with_ai():
    """Interface de chat avec l'assistant IA"""
    # Initialiser ou récupérer l'historique des conversations de la session
    if 'chat_history' not in session:
        session['chat_history'] = []
    
    # Traiter les messages envoyés par l'utilisateur
    if request.method == 'POST':
        user_message = request.form.get('user_message', '')
        if user_message:
            # Récupérer l'historique de la conversation
            conversation_history = session.get('chat_history', [])
            
            # Si cette requête est pour effacer l'historique
            if user_message.lower() == "effacer l'historique" or user_message.lower() == "effacer historique":
                session['chat_history'] = []
                return render_template('chat.html', chat_history=[], system_message="Historique de conversation effacé.")
            
            # Traiter d'abord tous les documents
            from document_processor import process_all_documents
            try:
                process_result = process_all_documents()
                logging.info(f"Traitement des documents avant la consultation IA: {process_result}")
            except Exception as e:
                logging.error(f"Erreur lors du traitement des documents: {str(e)}")
            
            # Appeler l'API d'OpenAI via notre module
            from ai_assistant import chat_with_assistant
            assistant_response, updated_history = chat_with_assistant(
                user_message=user_message,
                conversation_history=conversation_history
            )
            
            # Mettre à jour l'historique de la conversation dans la session
            session['chat_history'] = updated_history
            
            # Si c'est une requête AJAX, retourner un JSON
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return jsonify({
                    'response': assistant_response
                })
    
    # Afficher la page de chat avec l'historique
    return render_template('chat.html', chat_history=session.get('chat_history', []))


# Routes d'authentification
@app.route('/register', methods=['GET', 'POST'])
def register():
    """Enregistrement d'un nouvel utilisateur"""
    if 'user_id' in session:  # Vérifier la session directement
        return redirect(url_for('index'))
        
    if request.method == 'POST':
        email = request.form.get('email')
        username = request.form.get('username')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        
        # Validation de base
        if not email or not username or not password:
            flash('Email, nom d\'utilisateur et mot de passe sont obligatoires', 'danger')
            return redirect(url_for('register'))
            
        if password != confirm_password:
            flash('Les mots de passe ne correspondent pas', 'danger')
            return redirect(url_for('register'))
            
        # Vérification si l'utilisateur existe déjà
        user_email = User.query.filter_by(email=email).first()
        user_username = User.query.filter_by(username=username).first()
        
        if user_email:
            flash('Cet email est déjà utilisé', 'danger')
            return redirect(url_for('register'))
            
        if user_username:
            flash('Ce nom d\'utilisateur est déjà pris', 'danger')
            return redirect(url_for('register'))
            
        try:
            # Création du nouvel utilisateur
            user = User(
                email=email,
                username=username,
                first_name=first_name,
                last_name=last_name
            )
            user.set_password(password)
            
            # Premier utilisateur devient administrateur
            if User.query.count() == 0:
                user.is_admin = True
            
            db.session.add(user)
            db.session.commit()
            
            flash('Compte créé avec succès ! Vous pouvez maintenant vous connecter.', 'success')
            return redirect(url_for('login'))
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur lors de la création du compte: {str(e)}', 'danger')
            logging.error(f"Erreur lors de la création du compte: {str(e)}")
    
    return render_template('auth/register.html')


@app.route('/login', methods=['GET', 'POST'])
def login():
    """Connexion d'un utilisateur - Version simplifiée"""
    # Ajouter des logs d'authentification
    logging.info(f"Tentative de connexion - Session actuelle: {session}")
    
    # Vérifier si l'utilisateur est déjà connecté
    if 'user_id' in session:
        logging.info(f"Utilisateur déjà connecté avec ID: {session['user_id']}")
        return redirect(url_for('index'))
    
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        
        logging.info(f"Tentative de connexion pour l'utilisateur: {username}")
        
        if not username or not password:
            flash('Nom d\'utilisateur et mot de passe sont obligatoires', 'danger')
            return redirect(url_for('login'))
        
        # Vérification des identifiants
        user = User.query.filter_by(username=username).first()
        
        if not user or not user.check_password(password):
            flash('Identifiants incorrects, veuillez réessayer', 'danger')
            return redirect(url_for('login'))
        
        # Connexion réussie - simplification du processus
        session.clear()  # Nettoyer la session actuelle
        
        # Stocker les informations utilisateur dans la session
        session['user_id'] = user.id
        session['username'] = user.username
        
        # Assurer que la session est sauvegardée
        session.modified = True
        
        # Rediriger vers la page demandée ou la page d'accueil
        next_page = request.args.get('next')
        flash(f'Bienvenue, {user.username} !', 'success')
        
        logging.info(f"Authentification réussie pour {username} (ID: {user.id})")
        logging.info(f"Session après connexion: {session}")
        logging.info(f"Type de session: {type(session)}")
        
        return redirect(next_page if next_page and next_page != 'None' else url_for('index'))
    
    return render_template('auth/login.html')


@app.route('/logout')
@login_required
def logout():
    """Déconnexion d'un utilisateur"""
    # Consigner la déconnexion dans les logs
    if 'user_id' in session:
        logging.info(f"Déconnexion de l'utilisateur ID: {session.get('user_id')}")
    
    # Nettoyer complètement la session
    session.clear()
    
    # Configurer le message flash et rediriger
    flash('Vous avez été déconnecté avec succès.', 'info')
    return redirect(url_for('index'))


@app.route('/profile')
@login_required
def profile():
    """Affichage du profil de l'utilisateur"""
    # Récupérer les statistiques pour affichage
    properties_count = Property.query.count()
    buildings_count = Building.query.count()
    documents_count = Document.query.count()
    
    return render_template('auth/profile.html', 
                         properties_count=properties_count,
                         buildings_count=buildings_count, 
                         documents_count=documents_count)


@app.route('/profile/edit', methods=['GET', 'POST'])
@login_required
def edit_profile():
    """Modification du profil de l'utilisateur"""
    # Utiliser notre fonction pour récupérer l'utilisateur depuis session
    current_user = get_current_user()
    if not current_user:
        flash('Session expirée. Veuillez vous reconnecter.', 'warning')
        return redirect(url_for('login'))
        
    if request.method == 'POST':
        email = request.form.get('email')
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        current_password = request.form.get('current_password')
        new_password = request.form.get('new_password')
        confirm_password = request.form.get('confirm_password')
        
        # Validation de base
        if not email:
            flash('L\'email est obligatoire', 'danger')
            return redirect(url_for('edit_profile'))
            
        # Vérification si l'email est déjà utilisé (sauf par l'utilisateur actuel)
        user_email = User.query.filter(User.email == email, User.id != current_user.id).first()
        
        if user_email:
            flash('Cet email est déjà utilisé par un autre utilisateur', 'danger')
            return redirect(url_for('edit_profile'))
            
        try:
            # Mise à jour des informations de base
            current_user.email = email
            current_user.first_name = first_name
            current_user.last_name = last_name
            
            # Mise à jour du mot de passe si demandé
            if current_password and new_password:
                if not current_user.check_password(current_password):
                    flash('Mot de passe actuel incorrect', 'danger')
                    return redirect(url_for('edit_profile'))
                    
                if new_password != confirm_password:
                    flash('Les nouveaux mots de passe ne correspondent pas', 'danger')
                    return redirect(url_for('edit_profile'))
                    
                current_user.set_password(new_password)
                
            db.session.commit()
            flash('Profil mis à jour avec succès!', 'success')
            return redirect(url_for('profile'))
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur lors de la mise à jour du profil: {str(e)}', 'danger')
            logging.error(f"Erreur lors de la mise à jour du profil: {str(e)}")
    
    return render_template('auth/edit_profile.html')


# Test route pour vérifier l'état d'authentification
@app.route('/test_auth')
@login_required
def test_auth():
    """Route de test pour vérifier l'authentification"""
    # Afficher les informations de session
    logging.info(f"Test Auth - Session actuelle: {session}")
    
    session_info = {key: session.get(key) for key in session}
    is_authenticated = 'user_id' in session
    
    user_info = {
        "is_authenticated": is_authenticated,
        "session": session_info
    }
    
    if is_authenticated:
        current_user = get_current_user()
        if current_user:
            user_info["user_id"] = current_user.id
            user_info["username"] = current_user.username
        else:
            user_info["error"] = "ID utilisateur en session mais utilisateur non trouvé en base"
    
    return render_template('auth/test_auth.html', user_info=user_info)


# Routes pour la gestion des paiements
@app.route('/property/<int:property_id>/payments')
@login_required
def property_payments(property_id):
    """Afficher les paiements associés à une propriété"""
    property = Property.query.get_or_404(property_id)
    
    # Récupérer tous les paiements pour cette propriété
    payments = Payment.query.filter_by(property_id=property_id).all()
    
    # Vérifier et mettre à jour le statut des paiements en retard
    today = datetime.now().date()
    updated = False
    
    for payment in payments:
        if payment.is_rent_payment() and payment.check_late_status():
            payment.status = 'En retard'
            updated = True
    
    if updated:
        db.session.commit()
        # Récupérer à nouveau les paiements après la mise à jour
        payments = Payment.query.filter_by(property_id=property_id).all()
    
    # Tri des paiements par date (du plus récent au plus ancien)
    payments = sorted(payments, key=lambda x: x.payment_date, reverse=True)
    
    # Calculer les totaux directement ici plutôt que dans le template
    paid_total = sum(payment.amount for payment in payments if payment.status == 'Payé')
    pending_total = sum(payment.amount for payment in payments if payment.status == 'En attente')
    late_total = sum(payment.amount for payment in payments if payment.status == 'En retard')
    
    return render_template('payments/list.html', 
                          property=property, 
                          payments=payments,
                          paid_total=paid_total,
                          pending_total=pending_total,
                          late_total=late_total)


@app.route('/property/<int:property_id>/payment/add', methods=['GET', 'POST'])
@login_required
def add_payment(property_id):
    """Ajouter un paiement pour une propriété"""
    property = Property.query.get_or_404(property_id)
    
    if request.method == 'POST':
        amount = request.form.get('amount')
        payment_date_str = request.form.get('payment_date')
        payment_type = request.form.get('payment_type')
        payment_method = request.form.get('payment_method')
        status = request.form.get('status')
        description = request.form.get('description')
        
        # Conversion des données
        try:
            amount = float(amount) if amount else None
            payment_date = datetime.strptime(payment_date_str, '%Y-%m-%d').date() if payment_date_str else None
        except (ValueError, TypeError) as e:
            flash(f'Erreur lors de la conversion des données: {str(e)}', 'danger')
            return redirect(url_for('add_payment', property_id=property_id))
            
        # Validation
        if not amount or not payment_date or not payment_type:
            flash('Montant, date et type de paiement sont obligatoires', 'danger')
            return redirect(url_for('add_payment', property_id=property_id))
            
        # Création du paiement
        try:
            payment = Payment(
                property_id=property_id,
                amount=amount,
                payment_date=payment_date,
                payment_type=payment_type,
                payment_method=payment_method,
                status=status,
                description=description
            )
            
            db.session.add(payment)
            db.session.commit()
            
            flash('Paiement ajouté avec succès!', 'success')
            return redirect(url_for('property_payments', property_id=property_id))
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur lors de l\'ajout du paiement: {str(e)}', 'danger')
            logging.error(f"Erreur lors de l'ajout du paiement: {str(e)}")
    
    # Passer la date du jour au template
    today = datetime.now()
            
    return render_template('payments/add.html', property=property, now=today)


@app.route('/payment/<int:payment_id>/edit', methods=['GET', 'POST'])
@login_required
def edit_payment(payment_id):
    """Modifier un paiement existant"""
    payment = Payment.query.get_or_404(payment_id)
    property = Property.query.get_or_404(payment.property_id)
    
    if request.method == 'POST':
        amount = request.form.get('amount')
        payment_date_str = request.form.get('payment_date')
        payment_type = request.form.get('payment_type')
        payment_method = request.form.get('payment_method')
        status = request.form.get('status')
        description = request.form.get('description')
        
        # Conversion des données
        try:
            amount = float(amount) if amount else None
            payment_date = datetime.strptime(payment_date_str, '%Y-%m-%d').date() if payment_date_str else None
        except (ValueError, TypeError) as e:
            flash(f'Erreur lors de la conversion des données: {str(e)}', 'danger')
            return redirect(url_for('edit_payment', payment_id=payment_id))
            
        # Validation
        if not amount or not payment_date or not payment_type:
            flash('Montant, date et type de paiement sont obligatoires', 'danger')
            return redirect(url_for('edit_payment', payment_id=payment_id))
            
        # Mise à jour du paiement
        try:
            payment.amount = amount
            payment.payment_date = payment_date
            payment.payment_type = payment_type
            payment.payment_method = payment_method
            payment.status = status
            payment.description = description
            
            db.session.commit()
            
            flash('Paiement mis à jour avec succès!', 'success')
            return redirect(url_for('property_payments', property_id=payment.property_id))
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur lors de la mise à jour du paiement: {str(e)}', 'danger')
            logging.error(f"Erreur lors de la mise à jour du paiement: {str(e)}")
            
    return render_template('payments/edit.html', payment=payment, property=property)


@app.route('/payment/<int:payment_id>/delete', methods=['POST'])
@login_required
def delete_payment(payment_id):
    """Supprimer un paiement"""
    payment = Payment.query.get_or_404(payment_id)
    property_id = payment.property_id
    
    try:
        db.session.delete(payment)
        db.session.commit()
        flash('Paiement supprimé avec succès!', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Erreur lors de la suppression du paiement: {str(e)}', 'danger')
        logging.error(f"Erreur lors de la suppression du paiement: {str(e)}")
        
    return redirect(url_for('property_payments', property_id=property_id))


@app.route('/property/<int:property_id>/payment/recurring', methods=['GET', 'POST'])
@login_required
def add_recurring_payment(property_id):
    """Ajouter des paiements récurrents pour une propriété"""
    property = Property.query.get_or_404(property_id)
    
    if request.method == 'POST':
        # Récupérer les données du formulaire
        amount = request.form.get('amount')
        payment_type = request.form.get('payment_type')
        payment_method = request.form.get('payment_method')
        status = request.form.get('status')
        description = request.form.get('description')
        
        # Récupérer les paramètres de récurrence
        start_month = int(request.form.get('start_month'))
        start_year = int(request.form.get('start_year'))
        num_months = int(request.form.get('num_months'))
        payment_day = int(request.form.get('payment_day'))
        adjust_first_month = 'adjust_first_month' in request.form
        
        # Limiter le nombre de mois à 24 pour éviter les abus
        if num_months > 24:
            num_months = 24
            
        # Limiter le jour de paiement à 28 pour éviter les problèmes avec février
        if payment_day > 28:
            payment_day = 28
        
        # Conversion des données
        try:
            amount = float(amount) if amount else None
        except (ValueError, TypeError) as e:
            flash(f'Erreur lors de la conversion du montant: {str(e)}', 'danger')
            return redirect(url_for('add_recurring_payment', property_id=property_id))
            
        # Validation
        if not amount or not payment_type:
            flash('Montant et type de paiement sont obligatoires', 'danger')
            return redirect(url_for('add_recurring_payment', property_id=property_id))
        
        payments_created = 0
        
        try:
            # Créer les paiements récurrents
            for i in range(num_months):
                month = (start_month + i - 1) % 12 + 1  # Assurer que month est entre 1 et 12
                year = start_year + (start_month + i - 1) // 12  # Incrémenter l'année si nécessaire
                
                # Créer la date de paiement
                payment_date = datetime(year, month, payment_day).date()
                
                # Ajuster le montant du premier mois si demandé
                current_amount = amount
                if i == 0 and adjust_first_month and start_month == datetime.now().month and start_year == datetime.now().year:
                    # Nombre de jours dans le mois
                    days_in_month = calendar.monthrange(year, month)[1]
                    # Nombre de jours restants dans le mois depuis aujourd'hui
                    days_remaining = days_in_month - datetime.now().day + 1
                    # Calcul du montant ajusté au prorata
                    current_amount = round(amount * days_remaining / days_in_month, 2)
                    # Mise à jour de la description
                    payment_description = f"{description}\nMontant ajusté pour {days_remaining} jours sur {days_in_month}"
                else:
                    payment_description = description
                
                # Créer un nouveau paiement
                payment = Payment(
                    property_id=property_id,
                    amount=current_amount,
                    payment_date=payment_date,
                    payment_type=payment_type,
                    payment_method=payment_method,
                    status=status,
                    description=payment_description
                )
                
                db.session.add(payment)
                payments_created += 1
            
            db.session.commit()
            flash(f'{payments_created} paiements récurrents créés avec succès!', 'success')
            return redirect(url_for('property_payments', property_id=property_id))
        
        except Exception as e:
            db.session.rollback()
            flash(f'Erreur lors de la création des paiements récurrents: {str(e)}', 'danger')
            logging.error(f"Erreur lors de la création des paiements récurrents: {str(e)}")
    
    # Passer la date du jour au template
    today = datetime.now()
    
    return render_template('payments/add_recurring.html', property=property, now=today)


# Initialize the database
with app.app_context():
    # Import models
    from models import Property, Document, Building, User, Payment
    # Create tables
    db.create_all()
# Intégration du gestionnaire de fichiers pour les téléversements volumineux
from file_handler import file_handler
app.register_blueprint(file_handler)
